/**
 * 
 */
package (
    bof,
    bol,
    eof,
    eol,
    
    character,
    characteri,
    characterRange,
    characterRangei,
    anyCharacter,
    
    assert,
    assertNot,
    wordBoundary,
    notWordBoundary,
    
    choice,
    choicea,
    sequence,
    
    times,
    between,
    betweenNonGreedy,
    atMost,
    atLeast,
    
// Running
    exec)
with
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        eager,
        either,
        enumeration,
        fail,
        lookahead,
        many,
        many1,
        next,
        test,
        token},
    import 'parse/lang' lang {sepBy, sepEndBy, then},
    import 'parse/text' text {characters, match, string},
    import 'nu/stream' stream {first, rest, foldl, map, toArray},
    import 'nu/gen' gen
in {

var args = \args(...) -> args;

var join = (foldl, (+), '');

var contains = \a, x -> Array.prototype.indexOf.call(a, x) !== -1;

var joinP = \p -> bind(p, always <\ join);

var toLowerCase =  Function.prototype.call.bind(String.prototype.toLowerCase);
var toUpperCase =  Function.prototype.call.bind(String.prototype.toUpperCase);

var isLineTerminator = \x -> {
    switch (x) {
    case '\u000A':
    case '\u000D':
    case '\u2028':
    case '\u2029':
        return true;
    default:
        return false;
    }
};

var isWordChar = let
    wordChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
in
    (contains, wordChars);

/* 
 ******************************************************************************/
var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> String.fromCharCode
    \> always;

var not = \m -> 
    either(
        next(attempt <| m, fail()),
        always());

var previous = parse.extract(\x -> x.previous);

/* State
 ******************************************************************************/
var State = function(input, position, userState, previous) {
    parse.ParserState.call(this, input, position, userState);
    this.previous = previous;
};
State.prototype = new parse.ParserState;

State.prototype.next = \x -> {
    if (!this._next) {
        var s = new State(
            rest(this.input),
            this.position.increment(x),
            this.userState,
            x);
        this._next = \_, m, cok -> cok(x, s, m);
    }
    return this._next;
};

State.prototype.setInput = \input ->
    new State(input, this.position, this.userState, this.previous);

State.prototype.setPosition = \position ->
    new State(this.input, position, this.userState, this.previous);

State.prototype.setUserState = \userState ->
    new State(this.input, this.position, userState, this.previous);

/* Data
 ******************************************************************************/
var Data = function(group, endIndex, captures) {
    this.group = group;
    this.endIndex = endIndex;
    this.captures = captures;
};

Data.setGroup = \s, x ->
    new Data(x, s.endIndex, s.captures);

Data.setEndIndex = \s, x ->
    new Data(s.group, x, s.captures);

Data.setCaptures = \s, x ->
    new Data(s.group, s.endIndex, x);

/* Assertions
 ******************************************************************************/
/**
 * 
 */
bof = bind(
    parse.getPosition,
    \pos -> pos.index === 0 ? always('') : fail());

bol = either(
    bof,
    bind(previous, \prev ->
        isLineTerminator(prev) ? always('') : fail()));

/**
 * 
 */
eof = next(
    parse.eof,
    always(''));

eol = either(
    eof,
    next(
        lookahead <| token(isLineTerminator),
        always('')));


/**
 * Check the input matches a parser without consuming any input.
 */
assert = lookahead;

/**
 * Check the input does not match a parser without consuming any input.
 */
assertNot = assert <\ not;

/**
 * 
 */
wordBoundary = bind(previous, \p ->
    assert(token(\c ->
        isWordChar(c) && !isWordChar(p) ?
            always():
            fail())));

notWordBoundary = not <| wordBoundary;

/* Parsers
 ******************************************************************************/
/**
 * Match a single character
 */
character = text.character;

/**
 * Match a single character case insensitively
 */
characteri = \[c] ->
    text.characters(toLowerCase(c) + toUpperCase(c));

/**
 * Match a character in a range.
 */
characterRange = \start, end ->
    (gen.range(start.charCodeAt(0), end.charCodeAt(0) + 1, 1)
        |> (map, String.fromCharCode)
        |> join
        |> text.characters);

/**
 * Match a character in a range case insensitively.
 */
characterRangei = \[b], [c]->
    either(
        characterRange(toLowerCase(b), toLowerCase(c)),
        characterRange(toUpperCase(b), toUpperCase(c)));

/**
 * Match any character expect line terminators.
 */
anyCharacter = token((!) <\ isLineTerminator);

/**
 * Match the first of 1 or more patterns.
 * 
 * @param s Stream of patterns.
 */
choice = (map, attempt)
    \> toArray
    \> parse.choicea;

/**
 * 
 */
choicea = args
    \>> parse.choicea;

/* Quantifiers
 ******************************************************************************/
sequence = toArray
    \> parse.enumerationa
    \> joinP;

between = joinP <<\ lang.betweenTimes;

/**
 * @TODO: pretty damn ugly. 
 */
atMost = \max, p ->
    (max === 0 ? always(stream.end) :
        \state, m, cok, cerr, eok, eerr -> 
            let r = parse.trampoline <| eok(stream.end, state, m) in
                (r ? eok(stream.end, state, m) :
                    parse.cons(p, atMost(max, p))(state, m, cok, cerr, eok, eerr)));
        

atLeast = joinP <<\ lang.times;

betweenNonGreedy = joinP <<\ \min, max, p ->
    parse.append(
        lang.times(min, p),
        atMost(max - min, p));


/* Running
 ******************************************************************************/
exec = \pattern, input ->
    parse.parseState(
        pattern,
        new State(stream.from(input), parse.Position.initial, new Data(0, null, []), null),
        \x -> [x],
        \ -> null);


}
