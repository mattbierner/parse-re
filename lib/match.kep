/**
 * 
 */
package (
    bof,
    eof,
    
    character,
    characteri,
    characterRange,
    characterRangei,
    anyCharacter,
    
    assert,
    assertNot,
    
    choice,
    choicea,
    sequence,
    
    times,
    between,
    atMost,
    atLeast,
    
// Running
    exec)
with
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        eager,
        either,
        enumeration,
        fail,
        lookahead,
        many,
        many1,
        next,
        test,
        token},
    import 'parse/lang' lang {sepBy, sepEndBy, then},
    import 'parse/text' text {characters, match, string},
    import 'nu/stream' stream {first, rest, foldl, map, toArray},
    import 'nu/gen' gen
in {

var args = \args(...) -> args;

var join = (foldl, (+), '');

var joinP = \p -> bind(p, always <\ join);

var toLowerCase =  Function.prototype.call.bind(String.prototype.toLowerCase);
var toUpperCase =  Function.prototype.call.bind(String.prototype.toUpperCase);

var isLineTerminator = \x -> {
    switch (x) {
    case '\u000A':
    case '\u000D':
    case '\u2028':
    case '\u2029':
        return true;
    default:
        return false;
    }
};

/* 
 ******************************************************************************/
var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> String.fromCharCode
    \> always;

var not = \m -> 
    either(
        next(attempt <| m, fail()),
        always());

/* State
 ******************************************************************************/
var State = function(input, position, userState, previous) {
    parse.ParserState.call(this, input, position, userState);
    this.previous = previous;
};
State.prototype = new parse.ParserState;

State.prototype.next = \x -> {
    if (!this._next) {
        var s = new State(
            rest(this.input),
            this.position.increment(x),
            this.userState,
            x);
        this._next = \_, m, cok -> cok(x, s, m);
    }
    return this._next;
};

State.prototype.setInput = \input ->
    new State(input, this.position, this.userState, this.previous);

State.prototype.setPosition = \position ->
    new State(this.input, position, this.userState, this.previous);

State.prototype.setUserState = \userState ->
    new State(this.input, this.position, userState, this.previous);

/* Data
 ******************************************************************************/
var Data = function(group, endIndex, captures) {
    this.group = group;
    this.endIndex = endIndex;
    this.captures = captures;
};

Data.setGroup = \s, x ->
    new Data(x, s.endIndex, s.captures);

Data.setEndIndex = \s, x ->
    new Data(s.group, x, s.captures);

Data.setCaptures = \s, x ->
    new Data(s.group, s.endIndex, x);

/* Assertions
 ******************************************************************************/
/**
 * 
 */
bof = bind(
    parse.getPosition,
    \pos -> pos === 0 ? always() : fail());

eof = parse.eof;

/**
 * Check the input matches a parser without consuming any input.
 */
assert = lookahead;

/**
 * Check the input does not match a parser without consuming any input.
 */
assertNot = assert <\ not;

//wordBoundary = 

/* Parsers
 ******************************************************************************/
/**
 * Match a single character
 */
character = text.character;

/**
 * Match a single character case insensitively
 */
characteri = \[c] ->
    text.characters(toLowerCase(c) + toUpperCase(c));

/**
 * Match a character in a range.
 */
characterRange = \start, end ->
    (gen.range(start.charCodeAt(0), end.charCodeAt(0) + 1, 1)
        |> (map, String.fromCharCode)
        |> join
        |> text.characters);

/**
 * Match a character in a range case insensitively.
 */
characterRangei = \[b], [c]->
    either(
        characterRange(toLowerCase(b), toLowerCase(c)),
        characterRange(toUpperCase(b), toUpperCase(c)));

/**
 * Match any character expect line terminators.
 */
anyCharacter = token((!) <\ isLineTerminator);

/**
 * Match the first of 1 or more patterns.
 * 
 * @param s Stream of patterns.
 */
choice = (map, attempt)
    \> toArray
    \> parse.choicea;

/**
 * 
 */
choicea = args
    \>> parse.choicea;

/* Quantifiers
 ******************************************************************************/
sequence = toArray
    \> parse.enumerationa
    \> joinP;

between = joinP <<\ lang.betweenTimes;

atMost = \max, p ->
    between(0, max, p);

atLeast = joinP <<\ lang.times;

/* Running
 ******************************************************************************/
exec = \pattern, input ->
    parse.parseState(
        pattern,
        new State(stream.from(input), parse.Position.initial, new Data(0, null, []), null),
        \x -> [x],
        \ -> null);


}
