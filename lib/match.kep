/**
 * 
 */
package (
// Characters
    character,
    characteri,
    characterRange,
    characterRangei,
    anyCharacter,
    
// Character Classes
    digit,
    nonDigit,
    space,
    nonSpace,
    word,
    nonWord,
    
// Assertions
    assert,
    assertNot,
    wordBoundary,
    notWordBoundary,
    bof,
    bol,
    eof,
    eol,

//
    choice,
    choicea,
    sequence,
    
    between,
    betweenNonGreedy,
    atMost,
    
// Group
    group,
    backReference,
    
// Running
    matchStream,
    match,
    
    execStream,
    exec)
with
    import 'amulet/record' record,
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        eager,
        either,
        enumeration,
        getState,
        modifyState,
        fail,
        lookahead,
        many,
        many1,
        next,
        token},
    import 'parse/lang' lang {sepBy, sepEndBy, then},
    import 'parse/text' text {characters, string},
    import 'nu/stream' stream {first, rest, isEmpty, foldl, map, toArray},
    import 'nu/gen' gen
in {

var args = \args(...) -> args;

var join = (foldl, (+), '');

var copy = \arr{length} -> {
    var out = [];
    for (var i = 0; i < length; i = i + 1)
        out[i] = arr[i];
    return out;
};

var contains = \a, x -> Array.prototype.indexOf.call(a, x) !== -1;

var has = \o, i -> Object.hasOwnProperty.call(o, i);

var toLowerCase =  Function.prototype.call.bind(String.prototype.toLowerCase);
var toUpperCase =  Function.prototype.call.bind(String.prototype.toUpperCase);

var fromCharCode = \x -> String.fromCharCode(x);

var isLineTerminator = let
    lineTerminators = '\u2029\u2028\u000D\u000A'
in
    (contains, lineTerminators);

var isWordChar = let
    wordChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
in
    (contains, wordChars);

/* State
 ******************************************************************************/
/**
 * Parser State used for matching.
 * 
 * Keeps track of the previously consumed character.
 */
var State = record.declare(new parse.ParserState, [
    'input',
    'position',
    'userState',
    'previous']);

State.prototype.next = \x -> {
    if (!this._next) {
        var s = State.create(
            rest(this.input),
            this.position.increment(x),
            this.userState,
            x);
        this._next = \_, m, cok -> cok(x, s, m);
    }
    return this._next;
};

/* Data
 ******************************************************************************/
var Data = record.declare(null, [
    'groups',
    'captures']);

Data.setCapture = \s{captures}, i, x -> {
    var c = copy(captures);
    c[i] = x;
    return Data.setCaptures(s, c);
};

/* Base
 ******************************************************************************/
var empty = always('');

var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> fromCharCode
    \> always;
    
var joinP = \p -> bind(p, always <\ join);

var not = \m -> 
    either(
        next(attempt <| m, fail()),
        always());

var previous = parse.extract(\x -> x.previous);

var setCapture = \i, x ->
    modifyState(\s -> Data.setCapture(s, i, x));

/* Assertions
 ******************************************************************************/
var test = \p, f ->
    bind(p, \x -> f(x) ? empty : fail());

/**
 * Check the input matches a parser without consuming any input.
 */
assert = \p ->
    next(
        lookahead <| p,
        empty);

/**
 * Check the input does not match a parser without consuming any input.
 */
assertNot = not \> assert;

/**
 * Match the beginning of a file. Does not consume any input.
 */
bof = test(parse.getPosition, \pos -> pos.index === 0);

/**
 * Match the beginning of a line. Does not consume any input.
 */
bol = either(
    bof,
    test(previous, isLineTerminator));

/**
 * Match the end of a file. Does not consume any input.
 */
eof = assert <| parse.eof;

/**
 * Match the end of a line. Does not consume any input.
 */
eol = either(
    eof,
    assert <| token(isLineTerminator));

/**
 * Match a word boundary. Does not consume any input.
 */
wordBoundary = either(
    eof,
    assert <| bind(previous, \p ->
        token(\c -> isWordChar(c) && !isWordChar(p))));

/**
 * Does not match a word boundary. Does not consume any input.
 */
notWordBoundary = not <| wordBoundary;

/* Groups
 ******************************************************************************/
/**
 * Create a new group with name `i` for matcher `p`.
 * 
 * `p` is run and result is stored in the in state for later and as part of the
 * result.
 */
group = \p, i ->
    next(
        setCapture(i, ''),
        bind(p, \x ->
            next(
                setCapture(i, x),
                always(x))));

/**
 * Match a reference to group `i`.
 * 
 * If the group has already been consumed, matches the text of that captures.
 * Otherwise, matches using the referenced group. Non existent groups always
 * fail matching.
 */
backReference = \i ->
  bind(getState, \{captures, groups} ->
     has(captures, i) ?
         text.string(captures[i]) :
         (parse.lookahead <| groups[i]) || fail());

/* Character Matchers
 ******************************************************************************/
/**
 * Match a single character.
 */
character = text.character;

/**
 * Match a single character case insensitively.
 */
characteri = \c ->
    either(
        character(toLowerCase(c)),
        character(toUpperCase(c)));

/**
 * Match a character in a range.
 */
characterRange = let
    range = \start, end ->
        gen.range(start.charCodeAt(0), end.charCodeAt(0) + 1, 1)
in
    range
        \>> (map, fromCharCode)
        \>> join
        \>> text.characters;

/**
 * Match a character in a range case insensitively.
 */
characterRangei = \b, c ->
    either(
        characterRange(toLowerCase(b), toLowerCase(c)),
        characterRange(toUpperCase(b), toUpperCase(c)));

/**
 * Match any character expect a line terminator.
 */
anyCharacter = token((!) <\ isLineTerminator);

/* Character Class Matchers
 ******************************************************************************/
/**
 * Match any digit character.
 */
digit = characterRange('0', '9');

/**
 * Match any character except a digit.
 */
nonDigit = not <| digit;

/**
 * Match any space character
 */
space = text.characters("\u0009\u000b\u000c\u0020\u00a0\ufeff\u000a\u000d\u2028\u2029");

/**
 * Match any character except a space.
 */
nonSpace = not <| space;

/**
 * Match any word character.
 */
word = text.characters("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_");

/**
 * Match any non word character.
 */
nonWord = not <| word;

/* Parsers
 ******************************************************************************/
/**
 * Match the first of 1 or more patterns.
 * 
 * @param s Stream of patterns.
 */
choice = (map, attempt)
    \> toArray
    \> parse.choicea;

/**
 * 
 */
choicea = args \>> parse.choicea;

sequence = toArray
    \> parse.enumerationa
    \> joinP;

/* Quantifiers
 ******************************************************************************/
/**
 * Match `p` at most `max` times.
 * 
 * Unlike the regular `parse.js` parsers, this is locally non-greedy but will
 * attempt to consume as little input as possible to make the entire parsing
 * valid.
 * 
 * @TODO: pretty damn ugly. 
 */
atMost = \max, p ->
    (max === 0 ? always(stream.end) :
        \state, m, cok, cerr, eok, eerr -> 
            let r = parse.trampoline <| eok(stream.end, state, m) in
                (r ? r :
                    parse.cons(p, atMost(max, p))(state, m, cok, cerr, eok, eerr)));

/**
 * Greedily match a parser between `min` and `max` times.
 */
between = lang.betweenTimes \>> joinP;

/**
 * Non-Greedily match a parser between `min` and `max` times.
 * 
 * @see atMost for description of how non-greedy matching works.
 */
betweenNonGreedy = joinP <<\ \min, max, p ->
    parse.append(
        lang.times(min, p),
        atMost(max - min, p));

/* Running
 ******************************************************************************/
/**
 * Run `pattern` against input once and return the result.
 * 
 * returns either the set of captures or null if none.
 */
matchStream = \pattern, input ->
    parse.parseState(
        pattern.pattern,
        State.create(
            input,
            parse.Position.initial,
            Data.create(
                pattern.groups,
                []),
            null),
        \_, s -> s.userState.captures,
        \ -> null);
    
/**
 * @see matchStream
 * 
 * @param input Array like of characters.
 */
match = \pattern, input ->
    matchStream(
        pattern,
        stream.from(input));
    
/**
 * Run `pattern` against input incrementally until a match is found.
 * 
 * @param pattern Pattern
 * @param input Stream.
 */
execStream = \pattern, input -> {
    var result;
    var feed = input;
    do {
        result = matchStream(pattern, feed);
        if (isEmpty(feed))
            break;
        feed = rest(feed);
    } while (!result);
    return result;
};

/**
 * @see execStream
 * 
 * @param input Array like of characters.
 */
exec = \pattern, input ->
    execStream(
        pattern,
        stream.from(input));
}