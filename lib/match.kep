/**
 * 
 */
package (
    not,
        
// Characters
    character,
    characteri,
    characterRange,
    characterRangei,
    anyCharacter,
    
// Character Classes
    digit,
    notDigit,
    space,
    notSpace,
    word,
    notWord,
    
// Assertions
    assert,
    assertNot,
    wordBoundary,
    notWordBoundary,
    bof,
    bol,
    eof,
    eol,

//
    choice,
    choicea,
    sequence,
    
    times,
    between,
    betweenNonGreedy,
    atMost,
    atLeast,
    
// Group
    group,
    backReference,
    
// Running
    exec)
with
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        eager,
        either,
        enumeration,
        getState,
        modifyState,
        fail,
        lookahead,
        many,
        many1,
        next,
        token},
    import 'parse/lang' lang {sepBy, sepEndBy, then},
    import 'parse/text' text {characters, match, string},
    import 'nu/stream' stream {first, rest, foldl, map, toArray},
    import 'nu/gen' gen
in {

var args = \args(...) -> args;

var join = (foldl, (+), '');

var copy = \arr{length} -> {
    var out = [];
    for (var i = 0; i < length; i = i + 1)
        out[i] = arr[i];
    return out;
};

var contains = \a, x -> Array.prototype.indexOf.call(a, x) !== -1;

var joinP = \p -> bind(p, always <\ join);

var toLowerCase =  Function.prototype.call.bind(String.prototype.toLowerCase);
var toUpperCase =  Function.prototype.call.bind(String.prototype.toUpperCase);

var fromCharCode = \x -> String.fromCharCode(x);

var isLineTerminator = \x -> {
    switch (x) {
    case '\u000A':
    case '\u000D':
    case '\u2028':
    case '\u2029':
        return true;
    default:
        return false;
    }
};

var isWordChar = let
    wordChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
in
    (contains, wordChars);

/* 
 ******************************************************************************/
var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> fromCharCode
    \> always;

not = \m -> 
    either(
        next(attempt <| m, fail()),
        always());

var previous = parse.extract(\x -> x.previous);

/* State
 ******************************************************************************/
var State = function(input, position, userState, previous) {
    parse.ParserState.call(this, input, position, userState);
    this.previous = previous;
};
State.prototype = new parse.ParserState;

State.prototype.next = \x -> {
    if (!this._next) {
        var s = new State(
            rest(this.input),
            this.position.increment(x),
            this.userState,
            x);
        this._next = \_, m, cok -> cok(x, s, m);
    }
    return this._next;
};

State.prototype.setInput = \input ->
    new State(input, this.position, this.userState, this.previous);

State.prototype.setPosition = \position ->
    new State(this.input, position, this.userState, this.previous);

State.prototype.setUserState = \userState ->
    new State(this.input, this.position, userState, this.previous);

/* Data
 ******************************************************************************/
var Data = function(group, groups, endIndex, captures) {
    this.group = group;
    this.groups = groups;
    this.endIndex = endIndex;
    this.captures = captures;
};


Data.setGroup = \s, x ->
    new Data(x, s.groups, s.endIndex, s.captures);

Data.setEndIndex = \s, x ->
    new Data(s.group, s.groups, x, s.captures);

Data.setCaptures = \s, x ->
    new Data(s.group, s.groups, s.endIndex, x);

/* Base
 ******************************************************************************/
var empty = always('');

/* Assertions
 ******************************************************************************/
/**
 * Check the input matches a parser without consuming any input.
 */
assert = \p ->
    next(
        lookahead <| p,
        empty);

/**
 * Check the input does not match a parser without consuming any input.
 */
assertNot = not \> assert;

var test = \p, f ->
    bind(p, \x -> f(x) ? empty : fail());

/**
 * Match the beginning of a file. Does not consume any input.
 */
bof = test(parse.getPosition, \pos -> pos.index === 0);

/**
 * Match the beginning of a line. Does not consume any input.
 */
bol = either(
    bof,
    test(previous, isLineTerminator));

/**
 * Match the end of a file. Does not consume any input.
 */
eof = assert <| parse.eof;

/**
 * Match the end of a line. Does not consume any input.
 */
eol = either(
    eof,
    assert <| token(isLineTerminator));

/**
 * Match a word boundary. Does not consume any input.
 */
wordBoundary = either(
    eof,
    assert <| bind(previous, \p ->
        token(\c -> isWordChar(c) && !isWordChar(p))));

/**
 * Does not match a word boundary. Does not consume any input.
 */
notWordBoundary = not <| wordBoundary;

/* Groups
 ******************************************************************************/

group = \p, i ->
    bind(getState, \s -> {
        var captures = s.captures;
        if (i < captures.length)
            return always('');
        
        return next(
            modifyState(\s -> {
                var c = copy(s.captures);
                c[i] = '';
                return Data.setCaptures(s, c);
            }),
            bind(p, \x -> 
                next(
                    modifyState(\s -> {
                        var c = copy(s.captures);
                        c[i] = x;
                        return Data.setCaptures(s, c);
                    }),
                    always(x))));
    });
    
backReference = \i ->
      bind(getState, \s ->
         let captures = s.captures in
             (i < captures.length ?
                 text.string(captures[i]) :
                 let groups = s.groups in
                     (i < groups.length ?
                         groups[i] :
                         fail())));
         
/* Parsers
 ******************************************************************************/
/**
 * Match a single character
 */
character = text.character;

/**
 * Match a single character case insensitively
 */
characteri = \[c] ->
    text.characters(toLowerCase(c) + toUpperCase(c));

/**
 * Match a character in a range.
 */
characterRange = \start, end ->
    (gen.range(start.charCodeAt(0), end.charCodeAt(0) + 1, 1)
        |> (map, fromCharCode)
        |> join
        |> text.characters);

/**
 * Match a character in a range case insensitively.
 */
characterRangei = \[b], [c]->
    either(
        characterRange(toLowerCase(b), toLowerCase(c)),
        characterRange(toUpperCase(b), toUpperCase(c)));

/**
 * Match any character expect line terminators.
 */
anyCharacter = token((!) <\ isLineTerminator);

/**
 * Match the first of 1 or more patterns.
 * 
 * @param s Stream of patterns.
 */
choice = (map, attempt)
    \> toArray
    \> parse.choicea;

/**
 * 
 */
choicea = args \>> parse.choicea;

/* Character Classes
 ******************************************************************************/
digit = characterRange('0', '9');

notDigit = not <| digit;

space = text.characters("\u0009\u000b\u000c\u0020\u00a0\ufeff\u000a\u000d\u2028\u2029");

notSpace = not <| space;

word = text.characters("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_");

notWord = not <| word;

/* Quantifiers
 ******************************************************************************/
sequence = toArray
    \> parse.enumerationa
    \> joinP;

between = joinP <<\ lang.betweenTimes;

/**
 * @TODO: pretty damn ugly. 
 */
atMost = \max, p ->
    (max === 0 ? always(stream.end) :
        \state, m, cok, cerr, eok, eerr -> 
            let r = parse.trampoline <| eok(stream.end, state, m) in
                (r ? eok(stream.end, state, m) :
                    parse.cons(p, atMost(max, p))(state, m, cok, cerr, eok, eerr)));

atLeast = joinP <<\ lang.times;

betweenNonGreedy = joinP <<\ \min, max, p ->
    parse.append(
        lang.times(min, p),
        atMost(max - min, p));


/* Running
 ******************************************************************************/
exec = \pattern, input ->
    parse.parseState(
        pattern.pattern,
        new State(stream.from(input), parse.Position.initial, new Data(0, pattern.groups, null, []), null),
        \x, s -> s.userState.captures,
        \ -> null);


}
