/**
 * @fileOverview Regular expression grammar parsers.
 */
package (
    pattern,
    
// Flags
    RE_NONE,
    RE_I,
    RE_G,
    RE_M,
    
// Evaluation
    evaluate)
with
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        choice,
        choicea,
        either,
        enumeration,
        fail,
        getState,
        many,
        many1,
        next,
        optional,
        rec,
        sequence,
        test,
        token},
    import 'parse/lang' {between, sepBy, sepEndBy, times, then},
    import 'parse/text' {character, characters, string},
    import 'nu/stream' {foldl, map, toArray},
    import 'nu/gen' gen,
    import 'parse_re/match' match
in {

var identity = \x -> x;

var constant = \x -> \() -> x;

var join = (foldl, (+), '');

var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> String.fromCharCode
    \> always;

/* Forward
 ******************************************************************************/
var disjunction = \args(...) -> disjunction.apply(null, args);

var classRanges = \args(...) -> classRanges.apply(null, args);

/* Escapes
 ******************************************************************************/
var decimalDigit = characters('0123456789');

var decimalDigits = bind(
    many1(decimalDigit),
    \x -> (x
        |> join
        |> parseInt
        |> always));

var decimalIntegerLiteral = bind(decimalDigits, parseInt \> always);

/* 
 ******************************************************************************/
var reChar = always <\ character;

var classChar = \c ->
    bind(c, \x ->
        bind(getState, \s -> 
            always(s & RE_I ?
                match.characteri(x) :
                match.character(x))));

var matchBof = bind(getState, \s -> 
    always(s & RE_M ?
        match.bol :
        match.bof));

var matchEof = bind(getState, \s -> 
    always(s & RE_M ?
        match.eol :
        match.eof));

/* Escapes
 ******************************************************************************/
var hexDigit = characters('0123456789abcdefABCDEF');

var hexEscapeSequence = next(
    character('x'),
    bind(times(2, hexDigit),
        fromCharCodeParser));

var unicodeEscapeSequence = next(
    character('u'),
    bind(times(4, hexDigit),
        fromCharCodeParser));

var decimalEscape = decimalIntegerLiteral;

/**
 * 
 */
var characterClassEscape = choice(
    next(
        character('d'),
        always(match.digit)),
    
    next(
        character('D'),
        always(match.notDigit)),
    
    next(
        character('s'),
        always(match.space)),
    
    next(
        character('S'),
        always(match.notSpace)),
    
    next(
        character('d'),
        always(match.word)),
        
    next(
        character('D'),
        always(match.notWord)));

var identityEscape = parse.anyToken; //TODO

/**
 * 
 */
var controlLetter = bind(
    characters('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
    \x -> let
        i = x.charCodeAt(0),
        j = i % 32
    in
        always(character(String.fromCharCode(j))));

var controlEscape = let
    map = \from, to ->
        bind(
            character(from),
            constant <| reChar(to))
in
    choice(
        map('t', '\u0009'),
        map('n', '\u000A'),
        map('v', '\u000B'),
        map('f', '\u000C'),
        map('r', '\u000D'));
        
var characterEscape = choice(
    controlEscape,
    next(
        character('c'),
        controlLetter),
    hexEscapeSequence,
    unicodeEscapeSequence,
    identityEscape);

var classEscape = choice(
    decimalEscape,
    character('b'),
    characterEscape,
    characterClassEscape);



/* Character Classes
 ******************************************************************************/
var classAtomNoDash = choice(
    token((!) <\ (test, characters('\\-]'))),
    next(
        character('\\'),
        classEscape));

/**
 * 
 */
var classAtom = either(
    character('-'),
    classAtomNoDash);

/**
 * 
 */
var nonEmptyClassRangesNoDash = rec(\nonEmptyClassRangesNoDash -> let
    classRange = binds(
        enumeration(
            then(
                classAtomNoDash,
                character('-')),
            classAtom),
        always <<\ match.characterRange)
in
    choice(
        attempt <| bind(
            enumeration(
                classRange,
                classRanges),
            always <\ match.choice),
        attempt <| bind(
            enumeration(
                classChar(classAtomNoDash),
                nonEmptyClassRangesNoDash),
            always <\ match.choice),
        classChar(classAtom)));

/**
 * 
 */
var nonEmptyClassRanges = let
    classRange = binds(
        enumeration(
            then(
                classAtom,
                character('-')),
            classAtom),
        always <<\ match.characterRange)
in
    choice(
        attempt <| bind(
            enumeration(
                classRange,
                classRanges),
            always <\ match.choice),
        attempt <| bind(
            enumeration(
                classChar(classAtom),
                nonEmptyClassRangesNoDash),
            always <\ match.choice),
        classChar(classAtom));

/**
 * 
 */
classRanges = optional(fail(), nonEmptyClassRanges);

/**
 * 
 */
var characterClass = between(character('['), character(']'),
    either(
        next(
            character('^'), 
            bind(classRanges, \range ->
                always(token((!) <\ (test, range))))),
        classRanges));

/* Atom
 ******************************************************************************/
/**
 * 
 */
var atomEscape = choice(
    classChar(decimalEscape),
    classChar(characterEscape),
    characterClassEscape);

/**
 * 
 */
var patternCharacter = token(\tok -> {
    switch (tok) {
        case '^':
        case '$':
        case '\\':
        case '.':
        case '*':
        case '+':
        case '?':
        case '(':
        case ')':
        case '[':
        case ']':
        case '{':
        case '}':
        case '|':
            return false;
        default:
            return true;
    }
});

/**
 * 
 */
var atom = choice(
    classChar(patternCharacter),
    
    next(
        character('.'),
        always(match.anyCharacter)),
    
    next(
        character('\\'),
        atomEscape),
    
    characterClass,
    
    between(character('('), character(')'),
        bind(
            either(
                next(
                    parse.optional(null, string('?:')),
                    disjunction),
                disjunction),
            always <\ match.group)));

/**
 * 
 */
var quantifierPrefix = choice(
    next(
        character('*'),
        always([0, Infinity])),
    
    next(
        character('+'),
        always([1, Infinity])),
    
    next(
        character('?'),
        always([0, 1])),
    
    between(character('{'), character('}'),
        binds(
            enumeration(
                decimalDigits,
                optional(null, character(',')),
                optional(Infinity, decimalDigits)),
            \lower, hasUpper, upper ->
                always(hasUpper ?
                    [lower, upper] :
                    [lower, lower]))));

/**
 * 
 */
var quantifier = binds(
    enumeration(
        quantifierPrefix,
        optional(false, character('?'))),
    \[min, max], lazy ->
        always(lazy ?
            (match.betweenNonGreedy, min, max) :
            (match.between, min, max)));

/**
 * 
 */
var assertion = choice(
    next(
        character('^'),
        matchBof),
    
    next(
        character('$'),
        matchEof),
    
    next(
        string('\\b'),
        always(match.wordBoundary)),
    
    next(
        string('\\B'),
        always(match.notWordBoundary)),
    
    between(character('('), character(')'),
        bind(
            either(
                next(string('?='), always(match.assert)),
                next(string('?!'), always(match.assertNot))),
            \x -> bind(disjunction, always <\ x))));

/**
 * 
 */
var term = choice(
    attempt <| assertion,
    binds(
        enumeration(
            atom,
            optional(identity, quantifier)),
        \atom, quantifier ->
            always(quantifier(atom))));

/**
 * 
 */
var alternative = bind(
    many(term),
    always <\ match.sequence);

/**
 * 
 */
disjunction = bind(
    sepBy(character('|'),
        alternative),
    always <\ match.choice);

/**
 * 
 */
pattern = bind(
    disjunction,
    always <\ match.group);

/* Evaluation
 ******************************************************************************/
RE_NONE = 0;
RE_I = 1 << 0;
RE_G = 1 << 1;
RE_M = 1 << 2;

evaluate = \input, flags ->
    parse.run(
        pattern,
        input,
        (flags || RE_NONE));

}
