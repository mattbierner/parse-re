/**
 * @fileOverview Regular expression grammar parsers.
 */
package (
    pattern,
    
// Flags
    RE_NONE,
    RE_I,
    RE_G,
    RE_M,
    
// Evaluation
    evaluate)
with
    import 'amulet/record' record,
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        choice,
        choicea,
        either,
        enumeration,
        fail,
        getState,
        many,
        many1,
        next,
        optional,
        rec,
        sequence,
        test,
        token},
    import 'parse/lang' {between, sepBy, sepEndBy, times, then},
    import 'parse/text' text {character, characters, string},
    import 'nu/stream' {foldl, map, toArray},
    import 'nu/gen' gen,
    import 'parse_re/match' match
in {

/* Forward
 ******************************************************************************/
var disjunction = \args(...) -> disjunction.apply(null, args);

var classRanges = \args(...) -> classRanges.apply(null, args);

/*
 ******************************************************************************/
var identity = \x -> x;

var constant = \x -> \() -> x;

var join = (foldl, (+), '');

var copy = \arr{length} -> {
    var out = [];
    for (var i = 0; i < length; i = i + 1)
        out[i] = arr[i];
    return out;
};

var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> String.fromCharCode
    \> always;

/* Data
 ******************************************************************************/
var Data = record.declare(null, [
    'flags',
    'groups']);

var addGroup = \a, g -> {
    var c = copy(a);
    c.push(g);
    return c;
};

var setGroup = \a, i, g -> {
    var c = copy(a);
    c[i] = g;
    return c;
};

Data.addGroup = \s, g ->
    s.setGroups(addGroup(s.groups, g));

Data.setGroup = \s, i, g ->
    s.setGroups(setGroup(s.groups, i, g));


/* Escapes
 ******************************************************************************/
var decimalDigit = characters('0123456789');

var decimalDigits = bind(
    many1(decimalDigit),
    \x -> (x
        |> join
        |> parseInt
        |> always));

var decimalIntegerLiteral = bind(decimalDigits, parseInt \> always);

/* 
 ******************************************************************************/
var reChar = always <\ character;

var classChar = \c ->
    bind(c, \x ->
        bind(getState, \s -> 
            always(s.flags & RE_I ?
                match.characteri(x) :
                match.character(x))));

var matchCharacterRange = \from, to ->
    bind(getState, \s -> 
        always(s.flags & RE_I ?
            match.characterRangei(from, to) :
            match.characterRange(from, to)));
    
var matchBof = bind(getState, \s -> 
    always(s.flags & RE_M ?
        match.bol :
        match.bof));

var matchEof = bind(getState, \s -> 
    always(s.flags & RE_M ?
        match.eol :
        match.eof));

var group = \p ->
    next(
        parse.modifyState(\s -> Data.addGroup(s, null)),
        bind(parse.getState, \s ->
            let i = s.groups.length - 1 in
                bind(p, \p ->
                    let impl = match.group(p, i) in
                        parse.next(
                            parse.modifyState(\s -> Data.setGroup(s, i, impl)),
                            always(impl)))));

/* Escapes
 ******************************************************************************/
var hexDigit = characters('0123456789abcdefABCDEF');

var hexEscapeSequence = next(
    character('x'),
    bind(times(2, hexDigit),
        fromCharCodeParser));

/**
 * 
 */
var unicodeEscapeSequence = next(
    character('u'),
    bind(times(4, hexDigit),
        fromCharCodeParser));

/**
 * 
 */
var decimalEscape = decimalIntegerLiteral;

/**
 * Escapes representing a matcher for a class of characters.
 */
var characterClassEscape = choice(
    next(
        character('d'),
        always(match.digit)),
    
    next(
        character('D'),
        always(match.nonDigit)),
    
    next(
        character('s'),
        always(match.space)),
    
    next(
        character('S'),
        always(match.nonSpace)),
    
    next(
        character('d'),
        always(match.word)),
        
    next(
        character('D'),
        always(match.nonWord)));


var identifierPart = choice(
    text.character,
    characters('$_'),
    text.digit);

var identityEscape = either(
    characters('\u200C\u200D'),
    token((!) <\ (test, identifierPart)));

/**
 * 
 */
var controlLetter = bind(
    characters('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
    \x -> let
        i = x.charCodeAt(0),
        j = i % 32
    in
        always(reChar(String.fromCharCode(j))));

var controlEscape = let
    map = \from, to ->
        bind(
            character(from),
            constant <| reChar(to))
in
    choice(
        map('t', '\u0009'),
        map('n', '\u000A'),
        map('v', '\u000B'),
        map('f', '\u000C'),
        map('r', '\u000D'));

var characterEscape = choice(
    controlEscape,
    next(
        character('c'),
        controlLetter),
    hexEscapeSequence,
    unicodeEscapeSequence,
    identityEscape);

var classEscape = choice(
    decimalEscape,
    character('b'),
    characterEscape,
    characterClassEscape);

/* Character Classes
 ******************************************************************************/
var classAtomNoDash = either(
    token((!) <\ (test, characters('\\-]'))),
    next(
        character('\\'),
        classEscape));

/**
 * 
 */
var classAtom = either(
    character('-'),
    classAtomNoDash);

/**
 * 
 */
var nonEmptyClassRangesNoDash = rec(\nonEmptyClassRangesNoDash -> let
    classRange = binds(
        enumeration(
            then(
                classAtomNoDash,
                character('-')),
            classAtom),
        matchCharacterRange)
in
    choice(
        attempt <| bind(
            enumeration(
                classRange,
                classRanges),
            always <\ match.choice),
        attempt <| bind(
            enumeration(
                classChar(classAtomNoDash),
                nonEmptyClassRangesNoDash),
            always <\ match.choice),
        classChar(classAtom)));

/**
 * 
 */
var nonEmptyClassRanges = let
    classRange = binds(
        enumeration(
            then(
                classAtom,
                character('-')),
            classAtom),
        matchCharacterRange)
in
    choice(
        attempt <| bind(
            enumeration(
                classRange,
                classRanges),
            always <\ match.choice),
        attempt <| bind(
            enumeration(
                classChar(classAtom),
                nonEmptyClassRangesNoDash),
            always <\ match.choice),
        classChar(classAtom));

/**
 * 
 */
classRanges = optional(fail(), nonEmptyClassRanges);

/**
 * 
 */
var characterClass = between(character('['), character(']'),
    either(
        next(
            character('^'), 
            bind(classRanges, \range ->
                always(token((!) <\ (test, range))))),
        classRanges));

/* Atom
 ******************************************************************************/
/**
 * 
 */
var atomEscape = choice(
    bind(
        decimalEscape,
        always <\ match.backReference),
        
    classChar(characterEscape),
    
    characterClassEscape);

/**
 * 
 */
var patternCharacter = let
    reserved = '^$\\.*+?()[]{}|'
in
    token((!) <\ (test, characters(reserved)));

/**
 * 
 */
var atom = choice(
    classChar(patternCharacter),
    
    next(
        character('.'),
        always(match.anyCharacter)),
    
    next(
        character('\\'),
        atomEscape),
    
    characterClass,
    
    between(character('('), character(')'),
        either(
            next(
                string('?:'),
                disjunction),
            group(disjunction))));

/**
 * 
 */
var quantifierPrefix = choice(
    next(
        character('*'),
        always([0, Infinity])),
    
    next(
        character('+'),
        always([1, Infinity])),
    
    next(
        character('?'),
        always([0, 1])),
    
    between(character('{'), character('}'),
        binds(
            enumeration(
                decimalDigits,
                optional(null, character(',')),
                optional(Infinity, decimalDigits)),
            \lower, hasUpper, upper ->
                always(hasUpper ?
                    [lower, upper] :
                    [lower, lower]))));

/**
 * 
 */
var quantifier = binds(
    enumeration(
        quantifierPrefix,
        optional(false, character('?'))),
    \[min, max], lazy ->
        always(lazy ?
            (match.betweenNonGreedy, min, max) :
            (match.between, min, max)));

/* Assertion
 ******************************************************************************/
/**
 * 
 */
var assertion = choice(
    next(
        character('^'),
        matchBof),
    
    next(
        character('$'),
        matchEof),
    
    next(
        string('\\b'),
        always(match.wordBoundary)),
    
    next(
        string('\\B'),
        always(match.notWordBoundary)),
    
    between(character('('), character(')'),
        bind(
            either(
                next(string('?='), always(match.assert)),
                next(string('?!'), always(match.assertNot))),
            \x -> bind(disjunction, always <\ x))));

/* Pattern
 ******************************************************************************/
/**
 * 
 */
var term = choice(
    attempt <| assertion,
    binds(
        enumeration(
            atom,
            optional(identity, quantifier)),
        \atom, quantifier ->
            always(quantifier(atom))));

/**
 * 
 */
var alternative = bind(
    many(term),
    always <\ match.sequence);

/**
 * 
 */
disjunction = bind(
    sepBy(character('|'),
        alternative),
    always <\ match.choice);

/**
 * 
 */
pattern = group(disjunction);

/* Evaluation
 ******************************************************************************/
RE_NONE = 0;
RE_I = 1 << 0;
RE_G = 1 << 1;
RE_M = 1 << 2;

evaluate = \input, flags ->
    parse.parse(
        pattern,
        input,
        new Data((flags || RE_NONE), []),
        \_, {'userState':{groups}} -> ({
            'pattern': groups[0],
            'groups': groups
        }),
        \x -> { throw x; });

}