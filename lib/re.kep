/**
 * @fileOverview Regular expression grammar parsers.
 */
package (
    pattern,
    
// Flags
    RE_NONE,
    RE_I,
    RE_G,
    RE_M,
    
// Evaluation
    evaluate)
with
    import 'amulet/record' record,
    import 'parse/parse' parse {
        always,
        attempt,
        bind,
        binds,
        choice,
        either,
        enumeration,
        fail,
        getState,
        many,
        many1,
        modifyState,
        next,
        optional,
        rec,
        test,
        token},
    import 'parse/lang' {between, sepBy, sepEndBy, times, then},
    import 'parse/text' {anyChar, digit, character, characters, string},
    import 'nu/stream' {foldl, map, toArray},
    import 'nu/gen' gen,
    import 'parse_re/match' match
in {

/* Forward
 ******************************************************************************/
var disjunction = \args(...) -> disjunction.apply(null, args);

var classRanges = \args(...) -> classRanges.apply(null, args);

/*
 ******************************************************************************/
var identity = \x -> x;

var constant = \x -> \() -> x;

var join = (foldl, (+), '');

var copy = \arr{length} -> {
    var out = [];
    for (var i = 0; i < length; i = i + 1)
        out[i] = arr[i];
    return out;
};

var fromCharCodeParser =
    join
    \> \x -> parseInt(x, 16)
    \> String.fromCharCode
    \> always;

/* Data
 ******************************************************************************/
var Data = record.declare(null, [
    'flags',
    'groups']);

var addGroup = \a, g -> {
    var c = copy(a);
    c.push(g);
    return c;
};

var setGroup = \a, i, g -> {
    var c = copy(a);
    c[i] = g;
    return c;
};

Data.addGroup = \s, g ->
    s.setGroups(addGroup(s.groups, g));

Data.setGroup = \s, i, g ->
    s.setGroups(setGroup(s.groups, i, g));

/* Matchers
 ******************************************************************************/
/**
 * Create a matcher for a character.
 * 
 * Looks at flags to determine case sensitivity.
 */
var matchCharacter = \c ->
    bind(getState, \s -> 
        always(s.flags & RE_I ?
            match.characteri(c) :
            match.character(c)));

/**
 * Create a matcher for a character.
 * 
 * Looks at flags to determine case sensitivity.
 */
var matchCharacterFrom = \p ->
    bind(p, matchCharacter);

/**
 * Create a matcher for a character range.
 * 
 * Looks at flags to determine case sensitivity.
 */
var matchCharacterRange = \from, to ->
    bind(getState, \s -> 
        always(s.flags & RE_I ?
            match.characterRangei(from, to) :
            match.characterRange(from, to)));

/**
 * Create a beginning of file matcher.
 * 
 * Looks at flags to determine multiline behavior.
 */
var matchBof = bind(getState, \s -> 
    always(s.flags & RE_M ?
        match.bol :
        match.bof));

/**
 * Create a end of file matcher.
 * 
 * Looks at flags to determine multiline behavior.
 */
var matchEof = bind(getState, \s -> 
    always(s.flags & RE_M ?
        match.eol :
        match.eof));

var group = \p ->
    next(
        modifyState(\s -> Data.addGroup(s, null)),
        bind(getState, \s ->
            let i = s.groups.length - 1 in
                bind(p, \p ->
                    let impl = match.group(p, i) in
                        parse.next(
                            modifyState(\s -> Data.setGroup(s, i, impl)),
                            always(impl)))));

/* General Parsers
 ******************************************************************************/
var decimalDigit = characters('0123456789');

var hexDigit = characters('0123456789abcdefABCDEF');

var decimalDigits = many1(decimalDigit);

var decimalIntegerLiteral = bind(
    decimalDigits,
    join \> parseInt \> always);

var identifierPart = choice(
    anyChar,
    characters('$_'),
    digit);

/* Base Escapes
 ******************************************************************************/
/**
 * Character specified as a 2 digit unicode point.
 */
var hexEscapeSequence = next(
    character('x'),
    bind(times(2, hexDigit),
        fromCharCodeParser));

/**
 * Character specified as a 4 digit unicode point.
 */
var unicodeEscapeSequence = next(
    character('u'),
    bind(times(4, hexDigit),
        fromCharCodeParser));

/**
 * Decimal Character.
 */
var decimalEscape = decimalIntegerLiteral;

/**
 * Other escaped characters.
 */
var identityEscape = either(
    characters('\u200C\u200D'),
    token((!) <\ (test, identifierPart)));

/**
 * Escape for a special characters
 */
var controlEscape = let
    map = \from, to ->
        next(
            character(from),
            always(to))
in
    choice(
        map('t', '\u0009'),
        map('n', '\u000A'),
        map('v', '\u000B'),
        map('f', '\u000C'),
        map('r', '\u000D'));
 
/**
 * Escapes for a character calculated from a control letter's value.
 */
var controlLetter = bind(
    characters('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
    \x -> x.charCodeAt(0) % 32
        |> String.fromCharCode
        |> always);

/* Escapes Matchers
 ******************************************************************************/
/**
 * Escapes representing a matcher for a class of characters.
 */
var characterClassEscape = choice(
    next(
        character('d'),
        always(match.digit)),
    
    next(
        character('D'),
        always(match.nonDigit)),
    
    next(
        character('s'),
        always(match.space)),
    
    next(
        character('S'),
        always(match.nonSpace)),
    
    next(
        character('w'),
        always(match.word)),
    
    next(
        character('W'),
        always(match.nonWord)));

/* 
 ******************************************************************************/
var characterEscape = choice(
    controlEscape,
    next(
        character('c'),
        controlLetter),
    hexEscapeSequence,
    unicodeEscapeSequence,
    identityEscape);

var classEscape = choice(
    decimalEscape,
    next(
        character('b'),
        always('\u0008')),
    characterClassEscape,
    characterEscape);

/* Character Classes
 ******************************************************************************/
var classAtomNoDash = either(
    token((!) <\ (test, characters('\\-]'))),
    next(
        character('\\'),
        classEscape));

var classAtom = either(
    character('-'),
    classAtomNoDash);

/**
 * Correctly handles false ranges where either start or end is a matcher
 * and not a single character.
 */
var rangeFor = let 
    wrap = \c -> (typeof c === 'function' ? c : character(c))
in
    \start, end ->
        (typeof start === 'function' || typeof end === 'function' ?
            always(match.any(
                wrap(start),
                match.character('-'),
                wrap(end))) :
            matchCharacterRange(start, end));

var nonEmptyClassRangesNoDash = let
    classRange = binds(
        enumeration(
            then(
                classAtomNoDash,
                character('-')),
            classAtom),
        rangeFor)
in
    rec <| \nonEmptyClassRangesNoDash -> 
        choice(
            attempt <| bind(
                enumeration(
                    classRange,
                    classRanges),
                always <\ match.anys),
            
            attempt <| bind(
                enumeration(
                    matchCharacterFrom(classAtomNoDash),
                    nonEmptyClassRangesNoDash),
                always <\ match.anys),
            
            matchCharacterFrom(classAtom));

var nonEmptyClassRanges = let
    classRange = binds(
        enumeration(
            then(
                classAtom,
                character('-')),
            classAtom),
        rangeFor)
in
    choice(
        attempt <| bind(
            enumeration(
                classRange,
                classRanges),
            always <\ match.anys),
        
        attempt <| bind(
            enumeration(
                matchCharacterFrom(classAtom),
                nonEmptyClassRangesNoDash),
            always <\ match.anys),
        
        matchCharacterFrom(classAtom));

classRanges = optional(match.nothing, nonEmptyClassRanges);

/**
 * Pattern for a matcher that consumes a category of characters.
 */
var characterClass = between(character('['), character(']'),
    either(
        next(
            character('^'), 
            bind(
                classRanges,
                always <\ match.notToken)),
        classRanges));

/* Atom
 ******************************************************************************/
/**
 * 
 */
var atomEscape = choice(
    bind(
        decimalEscape,
        always <\ match.backReference),
        
    matchCharacterFrom(characterEscape),
    
    characterClassEscape);

/**
 * 
 */
var patternCharacter = let
    reserved = '^$\\.*+?()[]{}|'
in
    token((!) <\ (test, characters(reserved)));

/**
 * 
 */
var atom = choice(
    matchCharacterFrom(patternCharacter),
    
    next(
        character('.'),
        always(match.anyCharacter)),
    
    next(
        character('\\'),
        atomEscape),
    
    characterClass,
    
    between(character('('), character(')'),
        either(
            next(
                string('?:'),
                disjunction),
            group(disjunction))));

/**
 * 
 */
var quantifierPrefix = choice(
    next(
        character('*'),
        always([0, Infinity])),
    
    next(
        character('+'),
        always([1, Infinity])),
    
    next(
        character('?'),
        always([0, 1])),
    
    between(character('{'), character('}'),
        binds(
            enumeration(
                decimalIntegerLiteral,
                optional(null, character(',')),
                optional(Infinity, decimalIntegerLiteral)),
            \lower, hasUpper, upper ->
                always(hasUpper ?
                    [lower, upper] :
                    [lower, lower]))));

/**
 * 
 */
var quantifier = binds(
    enumeration(
        quantifierPrefix,
        optional(false, character('?'))),
    \[min, max], lazy ->
        always(lazy ?
            (match.betweenNonGreedy, min, max) :
            (match.between, min, max)));

/* Assertion
 ******************************************************************************/
/**
 * 
 */
var assertion = choice(
    next(
        character('^'),
        matchBof),
    
    next(
        character('$'),
        matchEof),
    
    next(
        string('\\b'),
        always(match.wordBoundary)),
    
    next(
        string('\\B'),
        always(match.notWordBoundary)),
    
    between(character('('), character(')'),
        bind(
            either(
                next(string('?='), always(match.assert)),
                next(string('?!'), always(match.assertNot))),
            \x -> bind(disjunction, always <\ x))));

/* Pattern
 ******************************************************************************/
/**
 * 
 */
var term = either(
    attempt <| assertion,
    binds(
        enumeration(
            atom,
            optional(identity, quantifier)),
        \atom, quantifier ->
            always(quantifier(atom))));

/**
 * 
 */
var alternative = bind(
    many(term),
    always <\ match.chains);

/**
 * 
 */
disjunction = bind(
    sepBy(character('|'),
        alternative),
    always <\ match.anys);

/**
 * 
 */
pattern = group(disjunction);

/* Evaluation
 ******************************************************************************/
RE_NONE = 0;
RE_I = 1 << 0;
RE_G = 1 << 1;
RE_M = 1 << 2;

evaluate = \input, flags ->
    parse.parse(
        pattern,
        input,
        new Data((flags || RE_NONE), []),
        \_, {'userState':{groups}} -> ({
            'pattern': groups[0],
            'groups': groups
        }),
        \x -> { throw x; });

}